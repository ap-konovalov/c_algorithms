// Коновалов А.П.

#include <stdio.h>
#define N 4
#define M 4
#define LenA 4
#define LenB 5

void Print2(int n, int m, int a[N][M])
{
    int i, j;
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < m; j++)
            printf("%4d", a[i][j]);
        printf("\n");
    }
}

int main(int argc, char *argv[])
{
    
//    Задание 1
//    *Количество маршрутов с препятствиями. Реализовать чтение массива с препятствием
//    и нахождение количество маршрутов.
    
    int A[N][M];
    // Зададим карту препятствий, 0 - препятствие
    int Map[N][M] =
    {
        {1,0,1,1},
        {1,1,1,1},
        {0,1,1,1},
        {1,1,0,1}
    };
    int i, j;
    for(j = 0; j < M; j++)
        // смотрим карту препятствий Map, если видим препятствие, значит в эту клеку пишем возможных ходов
         if (Map[0][j] == 1)
         {
             A[0][j] = 1;
         }
         else
         {
             A[0][j] = 0;
         }
    for(i = 1; i < N; i++)
    {
        // смотрим карту препятствий Map, если видим препятствие, значит в эту клеку пишем возможных ходов
        if (Map[i][0] == 1)
        {
        A[i][0] = 1;
        }
        else
        {
            Map[i][0] = 0;
        }
        for(j = 1; j < M; j++)
            if (Map[i][j] == 1)
            {
            A[i][j] = A[i][j-1] + A[i-1][j];
            }
            else if (Map[i][j] == 0)
            {
                A[i][j]=0;
            }
    }
    Print2(N, M, A);
    
    // Задача 2
    // Решить задачу о нахождении длины максимальной подпоследовательности с помощью матрицы.
    
    int sequenceA[LenA] = {1,3,5,6};    // Задаем подпоследовательность А
    int sequenceB[LenB] = {1,5,3,5,5};  // Задаем подпоследовательность B
    int answerArr[LenA + 1][LenB + 1];  // Задаем массив в котором подсчитаем длину максимальной общей  подпоследовательности
    
    for(i = 1 ; i <= LenA; i++)
    {
        for (j = 1; j <= LenB; j++)
        {
            // если элемент последовательности А равен элементу последовательности В то в массив запишем значение элемента слева сверху + 1
                if( sequenceA[i-1] == sequenceB[j-1])
                {
                    answerArr[i][j] = answerArr[i-1][j-1] + 1;
                }
            // если элемент последовательности А не равен элементу последовательности В то в массив запишем значение наибольшего из левого или верхнего элемента относительно текущего
                else if(answerArr[i-1][j] > answerArr[i][j-1])
                {
                    answerArr[i][j] =   answerArr[i-1][j] ;
                }
                else
                {
                    answerArr[i][j] = answerArr[i][j-1];
                }
        }
    }
    printf("Длина максимальной общей подпоследовательности = %i\n", answerArr[LenA][LenB]);
    
    
    return 0;
}

